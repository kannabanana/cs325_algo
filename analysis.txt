#NAME: SR Kanna, Isaac Stallcup
#COURSE: Algorithms CS325
#DATE: Fall 2016, 10/11/2016
#INSTRUCTOR: Amir Nayyeri

ANALYSIS OF ALGORITHMS PRESENTED

**********************************************************
First algorithm: name n2

Description
##########################################################

This algorithm takes, as inputs, the sets P and Q along
with N, the number of points in P and Q, and a counter
to keep track of the number of intersections.

The altorithm works by iterating through the elements of Q
starting from Q0 and working to QN for the current value
of N. For each Qi, it compares the values of Qi and QN.

Two points Pi, Pj with Pi < Pj have lines that intersect 
if their respective Q-values, Qi and Qj, satisfy the 
inequality Qi > Qj. 

In each comparison that the aglorithm performs between 
Qi and QN, it checks to see if the above "reversal" is
satisfied, namely that if Qi > QN, Pi < PN. If this is
true, the algorithm increments the counter variable 
keeping track of the # of intersections.

The algorithm is recursive, in that it calls itself with
N smaller by one after all comparisons for Qi -> QN have
been performed (again, i ranges from 0 to the current
value of N). The algorithm can shrink N becuase it is
uneccessary to compare Pi values to PN when i>n as we
can say that Pi > PN if i > N (P is sorted).

Runtime
##########################################################

This algorithm is O(N^2) time; all lines other than the
for loop on line 67 and the recursive call on line 77
have runtime O(1). The for loop has runtime of O(N), and
the recursive call performs this O(N) loop on each of the
N elements of Q, so the algorithm is O(N^2).

Proof of Correctness
##########################################################

The proof is inductive. The base case is where P and Q
contain one element; there are no interections to find and
so we have found all possible intersections.

The inductive hypothesis is that, for any lists P and Q
of size <= N, the number of intersections has been correctly
counted for lines between each (Pi, Qi) for 0 <= i < N.

For lists P' and Q', each with size N, prove that the algorthm
will correctly find all intersections. For the pairs (Pi, Qi)
for 0 <= i < N, the inductive hypothesis states that all
intersections will be correctly found. Then we must find all
intersections between (PN, QN) and each (Pi, Qi) for 
0 <= i < N. The algorithm checks each (Pi, Qi) against
(PN, QN) to see if an intersection exists.

It does this by checking if Qi > QN for Pi < PN; if this
inequality is true, there is an intersection. This checking
process finds all intersections between the line connecting
PN and QN with the lines connecting all Pi, Qi with
0 <= i < N.

Since the rest of the intersections are given by the inductive
hypothesis, any lists P, Q will have all intersections
found by the algorithm.

**********************************************************
Second algorithm: name mergeSort

Description
##########################################################

The algorithm is based on a traditional implementation of
mergeSort, and its essential operations are the same. It 
recursively divides lists in half, and operates on the
resulting two lists of half size. When the size of a list
is <= 1, the recursion stops.

It then proceeds through the recursive lists, comparing 
progressive items of each sublist and inserting the smaller.
However, the algorithm also uses this information to find
intersections with the aforementioned method    

#combine the two arrays
def combine(first,second):

	fo = open("output.txt","r")
	nlogn_intersection = fo.readline()
	print "nlogn_intersection inside COMBINE FUNCTION ",nlogn_intersection
				

	temp = []		#empty list

	#the first and second can't be zero
	while len(first) != 0 and len(second) != 0:
		if first[0] < second[0]:
			temp.append(first[0])
			first.remove(first[0])
		else:
			temp.append(second[0])
			second.remove(second[0])
	if len(first) == 0:
		temp += second
	else:
		temp += first
    
	return temp



#main function for mergesort
def mergesort(Q):

	#base case - length 0 or 1
	if len(Q) == 1 or len(Q) == 0:
   #     	return nlogn_intersection
		return Q

    	else:
		mid = len(Q)/2			#divide by two

		print "the length of Q is ",len(Q)	
		print "\n\nQ right now is ", Q
		i = 0;
		print "i in mergesort function is ",i
		print "m is ",mid
		j = mid+1;
		print "j in mergesort function is ",j
		print "\n\n"		



#following the algorithm - lets see what happens (follow the yellow brick road)
		for k in range(0,mid):
#			if Q[j]>Q[mid]:
			if j>mid:
				i += 1;
			
				fo = open("output.txt","r")
				nlogn_intersection = fo.readline()
			
				print "FIRST CASE nlogn_intersection is ",nlogn_intersection
			
				nlogn_intersection = int(nlogn_intersection)
				nlogn_intersection += 1;
				print "updated nlogn_intersection is ",nlogn_intersection

				output(nlogn_intersection)

			elif i>mid:
				j += 1;
		

#LOL this case never hits
			elif Q[i] < Q[j]:

				i += 1;
				fo = open("output.txt","r")
				nlogn_intersection = fo.readline()

				print "SECOND CASE nlogn_intersection is ",nlogn_intersection
				nlogn_intersection = int(nlogn_intersection)	
				nlogn_intersection += 1;
				print "updated nlogn_intersection is ",nlogn_intersection
				output(nlogn_intersection)

			else:
				j +=1;


       		first = mergesort(Q[:mid])	#recursive call on the mid
        	second = mergesort(Q[mid:])
        	return combine(first,second)



#function to output to output.txt
def output(intersection):
#	print "in output the intersetemption is ", intersection
	fo = open("output.txt","w+")		#will create output.txt if it doesn't exist
	fo.write(str(intersection))



#define main
def main():
	intersection = 0;

	#input list P,Q and number of line segments from a given text file
	N = input_listN(sys.argv[1]);	
	N = int(N)	#convert str to int


	#getting the P list without commas
	P = input_listP(sys.argv[1]);
	for i in range(0,len(P)):
		P[i] = int(P[i])
	
	#getting the Q list without commas (cheating because only one return and I know how many lines in text file)
	Q = input_listQ(sys.argv[1]);	
	for i in range(0,len(Q)):
		Q[i] = int(Q[i])

	
	#n2 algorithm
#	intersection = n2(P,Q,N-1,intersection);	
	#write to output function
#	output(intersection);

	nlogn_intersection = 0	
	output(nlogn_intersection);

	Q = mergesort(Q);
	print Q


#call main
main()
